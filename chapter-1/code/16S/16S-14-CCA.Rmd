---
title: "Canonical Correlation Analysis"
author: "Amy Solman"
date: "08/10/2021"
output: html_document
---

This script will carry out canonical correspondence analysis.
This is a multivariate method that explores the relationship between microbial assemblages and their environment.
The analysis extracts synthetic environmental gradients from the data.
The gradients can then be used to visualise habitat preferences via ordination diagrams.

The following code/explaination is taken from: https://rfunctions.blogspot.com/2016/11/canonical-correspondence-analysis-cca.html

Correspondence Analysis (CA) is a multivariate ordination analysis. It uses variables from a single data set to find new axes (orthogonal components) that explain variation within the dataset.CA assumes observations to have unimodal distributions (rather than linear as in principal component analysis), as is usually the case for species distributions = a species usually shows highest abundance in teh midrange of an environmental gradient. This is why CA and CCA is used by ecologists.

How is CCA different to CA? CANONICAL = something reduced to its most basic form. CCA is CA following a specific principal, looking fir relationships between groups of variables.

In CCA we need to specify two matrices - one with observations (e.g. species abundance) and the other has gradients (e.g. temperature). These observations should have unimodal distributions along gradients (e.g. more species as midrange temp). REMEMBER: if observations are linearly related to gradients (more species with temp) then we should use CANONICAL CORRELATION ANALYSIS (CANCOR) OR REDUNDANCY ANALYSIS (RDA) (THESE ARE MULTIVARIATE ANALOGS OF SIMPLE LINEAR REGRESSION).

PARTIAL CCA is similar to similar to CCA but controls for the effect of a third matrix. The effects of this third matrix are removes from the community matrix. The residual community matrix is used in the remaining part of the CCA. This can be used to remove the effects of spatial autocorrelation etc. 


I want to know how enviro/physical variables related to alpha diversity/community composition.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Clear workspace and load packages
```{r}
rm(list=ls())
graphics.off()

# library(ggpubr) #for making my boxplots
# library(FSA) #for dunn's test
library(vegan) #for diversity indices
# library(ggplot2) #for making plots
# library(dplyr) #for manipulating data where you see %>% and computing summary stats
# install.packages("dendextend")
# library(dendextend) #for hierchical clustering
# install.packages("indicspecies")
# library(indicspecies) #for indicator species analysis
# library(stringr) #for removing characters from string
# library(fossil) #for creating distance matrix
# # install.packages("betapart")
# library(betapart) #for didtance decay analysis
# library(ade4) #mantel tests

```

Load data 
```{r}
#Load data files
load("../data-output/18S-my-sequence-data.RData") #load all our pre-processed data files

#load phyloseq object
##################################################BOTH POLES#################################################
ps <- readRDS("../data-output/18S-my-phyloseq-object.rds") #load unrarefied phyloseq object
ps.rar <- readRDS("../data-output/18S-my-phyloseq-object-rarefied.rds") #load rarefied phyloseq objectcol

#All glaciers merged abundances
ps.glaciers.merged.RA <- readRDS("../data-output/18S-all-glaciers-merged-rarefied-abundant.rds") #merged glaciers abundant phyloseq object
ps.glaciers.merged.RR <- readRDS("../data-output/18S-all-glaciers-merged-rarefied-rare.rds") #merged glaciers rare phyloseq object
ps.glaciers.merged.I <- readRDS("../data-output/18S-all-glaciers-merged-rarefied-intermediate.rds") #merged glaciers intermediate phyloseq object
```

1 TOTAL TAXA 
1.1 Modify data
```{r}
#pull out count table and metadata
counts <- data.frame(t(otu_table(ps.rar)))

#count table with ASV IDs as taxonomic classifications
#taxa <- taxa_names(ps.rar)

meta <- data.frame(sample_data(ps.rar))

#keep only variables we want to include in our mode
meta_trim <- meta[,17:92]
#calcualte area
meta_trim$area <- pi*(meta_trim$NS/2)*(meta_trim$EW/2)
#remove diamter info
drops <- c("NS","EW")
meta_trim <- meta_trim[ , !(names(meta_trim) %in% drops)]
#remove more unneccessary columns
meta_trim <- meta_trim[,-c(64:74)]
#make dataframe numeric
meta_trim[] <- lapply(meta_trim, as.numeric)

#Initial CCA analysis suggested these were significant: #Distance to sea, elevation, water depth, total depth, mass, pH, C, TIN, TDP, DOP, C.N, Cl_meq, SO4, NA and K significant
keeps <- c("Distance_To_Sea", "Elevation", "Water_Depth", "Total_Depth", "Mass", "pH", "C", "TIN", "TDP", "DOP", "C.N", "Cl_meq", "SO4_mueq", "Na_mg", "K_mueq")
meta_trim_trim <- meta_trim[, (names(meta_trim) %in% keeps)]
# meta_trim_trim2 <- meta_trim[, (names(meta_trim) %in% keeps2)]
# 
# #remove rows with NA values
# meta_trim_complete <- meta_trim_trim[complete.cases(meta_trim_trim), ]
# 
# #only keep same count samples as in our metadata_trim_complete
# counts_trim <- counts[(row.names(counts) %in% row.names(meta_trim_complete)), ]

#Replace NAs with median values
f=function(x){
   x<-as.numeric(as.character(x)) #first convert each column into numeric if it is from factor
   x[is.na(x)] =median(x, na.rm=TRUE) #convert the item with NA to median value from the column
   x #display the column
}
meta_med=data.frame(apply(meta_trim_trim,2,f))

#rename counts columns with phylum
tax_tab <- data.frame(tax_table(ps.rar))
#replace NAs with Unknown
tax_tab[is.na(tax_tab)] <- "Unknown"
colnames(counts) <- tax_tab$Class

#aggregate count data
x <- t(counts)
new_df=aggregate(x, by=list(rownames(x)),sum)
new_counts <- t(new_df)
colnames(new_counts) <- new_counts[1,]
new_counts <- new_counts[-1,]
df <- data.frame(new_counts)
#make dataframe numeric
df[] <- lapply(df, as.numeric)
```

1.2 Apply log+1 tranformation to species data to correct for statistcial errors associated with rare/very common species
```{r}
spelog <- decostand(spe, "log")

asvlog <- decostand(counts, "log")

dflog <- decostand(df, "log")
```

1.3 Perform CCA, specifying that species is explained by environmental variables
```{r}
ccamodel1 <- cca(df~., meta_med, na.action = na.exclude)
```

1.4 Perform a partial CCA using a third matrix. We can do this by combining environmental and spatial matrices.
```{r}
# envspatial <- cbind(env,spatial) #bind the data frames
# 
# nams <- names(envspatial) #get out variable names
# 
# partialccamodel <- formula(paste("spe ~", paste(nams[1: (length(envspatial)-(length(spatial)) )], collapse = " + "),"+ Condition(", paste(nams[(length(envspatial)-(length(spatial)-1) ):length(envspatial)], collapse ="+"),")")) 
# #this generates the formula of species as explained by environmental variables while controlling for location (lat/long coors)
# 
# patrialccamodel <- cca(partialccamodel, envspatial)
```

1.5 We now have to automatically select variables of "env" than best explain "spe". We can do this by using a stepwise model from the "ordistep" function. We'll just do this with 
```{r}
finalmodel1 <- ordistep(ccamodel1, scope=formula(ccamodel1))
```

1.6 Next we calculate Variance Inflation Factors for each of the variables (constraints). If there is an env variable with VIF > 10 then this variable presents collinearity with other variables. We then have to delete from the dataset and redo our analysis.
```{r}
vif.cca(finalmodel1) #TDP, DOP, CL_meq, SO4, NA and K all VIF scores > 10 so I will remove them and run the analysis again

keeps <- c("Distance_To_Sea", "Elevation", "Water_Depth", "Total_Depth", "Mass", "pH", "C", "TIN", "C.N")
meta_trim_trim <- meta_trim[, (names(meta_trim) %in% keeps)]
meta_med=data.frame(apply(meta_trim_trim,2,f))
ccamodel2 <- cca(df~., meta_med, na.action = na.exclude)
finalmodel2 <- ordistep(ccamodel2, scope=formula(ccamodel2))
vif.cca(finalmodel2)
```

1.7 Now we will fit the stepwise model (ordistep function) using partial cca using lat and longitude as our conditioning variables
```{r}
partialccamodel <- formula(paste("spe ~", paste(nams[1: (length(envspatial)-(length(spatial)) )], collapse = " + "),"+ Condition(", paste(nams[(length(envspatial)-(length(spatial)-1) ):length(envspatial)], collapse ="+"),")"))

simplemodel<-cca(partialccamodel, envspatial)

finalmodelpartial<- ordistep(simplemodel, scope=formula(partialccamodel))

vif.cca(finalmodelpartial) #X and Y now have VIF > 10 so we should delete the variable and re-run the analysis.
```

1.8 Call the ccamodel and interpret results
```{r}
# ccamodel 

ccamodel2
#total inertia = total variance in species distributions
#constrained inertia = variance explained by environmental gradients
#proportion values = percentages of variance of species distributions explained by constrained (env) and unconstrained variables
#eigenvalues represent the amount of variance explained by each CCA axis (graphs usually present the first two constrained axes)

#use permutation test to see if whole CCA model, CCA terms (env variables) and CCA axes explain more variance of species (observations) than expected by chance (p < 0.05). If p > 0.05 then there is no point using the CCA.

#test significance of the model
anova.cca(finalmodel2) # p < 0.05 SIGNIFICANT!

#test significance of the terms
anova.cca(finalmodel1, by="terms") #Distance to sea, elevation, water depth, total depth, mass, pH, C, TIN, TDP, DOP, C.N, Cl_meq, SO4, NA and K significant

#test significance of the CCA axes - at least the first two or three should present a significant p value
anova.cca(finalmodel1, by="axis") #the first two are significant

#plot a graph of results
plot(finalmodel1, xlim=c(-1.5,2), ylim=c(-1,1.5), display=c("sp", "cn"), main="Total Taxa CCA Plot")
  
```

2 ABUNDANT TAXA

2.1 Prep data
```{r}
#pull out count table and metadata
counts.ab <- data.frame(t(otu_table(ps.glaciers.merged.RA)))
meta.ab <- data.frame(sample_data(ps.glaciers.merged.RA))

#keep only variables we want to include in our model
meta_trim.ab <- meta.ab[,17:92]
#calcualte area
meta_trim.ab$area <- pi*(meta_trim.ab$NS/2)*(meta_trim.ab$EW/2)
#remove diamter info
drops <- c("NS","EW")
meta_trim.ab <- meta_trim.ab[ , !(names(meta_trim.ab) %in% drops)]
#remove more unneccessary columns
meta_trim.ab <- meta_trim.ab[,-c(64:74)]
#make dataframe numeric
meta_trim.ab[] <- lapply(meta_trim.ab, as.numeric)

# #Initial CCA analysis suggested these were significant: #sig terms: distance to sea level, elevation, water depth, total depth, pH, TIN, TDP, DOP, Cl_meq, SO4_mueq, Na_mg, K_mueq - I'm going to re-run this analysis with these terms only
keeps <- c("Distance_To_Sea", "Elevation", "Water_Depth", "Total_Depth", "pH", "TIN", "TDP", "DOP", "Cl_meq", "SO4_mueq", "Na_mg", "K_mueq")
meta_trim_trim.ab <- meta_trim.ab[, (names(meta_trim.ab) %in% keeps)]

#Replace NAs with median values
f=function(x){
   x<-as.numeric(as.character(x)) #first convert each column into numeric if it is from factor
   x[is.na(x)] =median(x, na.rm=TRUE) #convert the item with NA to median value from the column
   x #display the column
}
meta_med.ab=data.frame(apply(meta_trim_trim.ab,2,f))

#rename counts columns with phylum
tax_tab.ab <- data.frame(tax_table(ps.glaciers.merged.RA))
#replace NAs with Unknown
tax_tab.ab[is.na(tax_tab.ab)] <- "Unknown"
colnames(counts.ab) <- tax_tab.ab$Class

#aggregate count data
x <- t(counts.ab)
new_df=aggregate(x, by=list(rownames(x)),sum)
new_counts <- t(new_df)
colnames(new_counts) <- new_counts[1,]
new_counts <- new_counts[-1,]
df.ab <- data.frame(new_counts)
#make dataframe numeric
df.ab[] <- lapply(df.ab, as.numeric)
```

2.2 Perform CCA, specifying that species is explained by environmental variables
```{r}
ccamodel1.ab <- cca(df.ab~., meta_med.ab, na.action = na.exclude)
```

2.3 We now have to automatically select variables of "env" than best explain "spe". We can do this by using a stepwise model from the "ordistep" function. We'll just do this with 
```{r}
finalmodel1.ab <- ordistep(ccamodel1.ab, scope=formula(ccamodel1.ab))
```

2.4 Next we calculate Variance Inflation Factors for each of the variables (constraints). If there is an env variable with VIF > 10 then this variable presents collinearity with other variables. We then have to delete from the dataset and redo our analysis.
```{r}
vif.cca(finalmodel1.ab) #VIF scores > 10 TDP, DOP, Cl_meq, SO4, Na, K
keeps <- c("Distance_To_Sea", "Elevation", "Water_Depth", "Total_Depth", "pH", "TIN")
meta_trim_trim.ab <- meta_trim.ab[, (names(meta_trim.ab) %in% keeps)]
meta_med.ab=data.frame(apply(meta_trim_trim.ab,2,f))
ccamodel2.ab <- cca(df.ab~., meta_med.ab, na.action = na.exclude)
finalmodel2.ab <- ordistep(ccamodel2.ab, scope=formula(ccamodel2.ab))
vif.cca(finalmodel2.ab)
```

2.5 Call the ccamodel and interpret results
```{r}
ccamodel2.ab

#test significance of the model
anova.cca(finalmodel2.ab) # p < 0.05 SIGNIFICANT!

#test significance of the terms
anova.cca(finalmodel2.ab, by="terms") #sig terms: distance to sea level, elevation, water depth, total depth, pH, TIN, TDP, DOP, Cl_meq, SO4_mueq, Na_mg, K_mueq - I'm going to re-run this analysis with these terms only

#test significance of the CCA axes - at least the first two or three should present a significant p value
anova.cca(finalmodel2.ab, by="axis") #the first two are significant

#plot a graph of results
plot(finalmodel2.ab, xlim=c(-1.5,2), ylim=c(-1,1.5), display=c("sp", "cn"), main="Abundant Taxa CCA Plot")
```

3 INTERMEDIATE TAXA

3.1 Prep data
```{r}
#pull out count table and metadata
counts.i <- data.frame(t(otu_table(ps.glaciers.merged.I)))
meta.i <- data.frame(sample_data(ps.glaciers.merged.I))

#keep only variables we want to include in our model
meta_trim.i <- meta.i[,17:92]
#calcualte area
meta_trim.i$area <- pi*(meta_trim.i$NS/2)*(meta_trim.i$EW/2)
#remove diamter info
drops <- c("NS","EW")
meta_trim.i <- meta_trim.i[ , !(names(meta_trim.i) %in% drops)]
#remove more unneccessary columns
meta_trim.i <- meta_trim.i[,-c(64:74)]
#make dataframe numeric
meta_trim.i[] <- lapply(meta_trim.i, as.numeric)

# # #Initial CCA analysis suggested these were significant: #sig terms: total depth, radius, mass, temp, conductivity, pH, DOC, C, TIN, C.N, NA_mg - I'm going to re-run this analysis with these terms only
keeps <- c("Total_Depth", "Radius", "Mass", "Temp", "Conductivity", "pH", "DOC", "C", "TIN","C.N","Na_mg")
meta_trim_trim.i <- meta_trim.i[, (names(meta_trim.i) %in% keeps)]

#Replace NAs with median values
f=function(x){
   x<-as.numeric(as.character(x)) #first convert each column into numeric if it is from factor
   x[is.na(x)] =median(x, na.rm=TRUE) #convert the item with NA to median value from the column
   x #display the column
}
meta_med.i=data.frame(apply(meta_trim_trim.i,2,f))

#rename counts columns with phylum
tax_tab.i <- data.frame(tax_table(ps.glaciers.merged.I))
#replace NAs with Unknown
tax_tab.i[is.na(tax_tab.i)] <- "Unknown"
colnames(counts.i) <- tax_tab.i$Class

#aggregate count data
x <- t(counts.i)
new_df=aggregate(x, by=list(rownames(x)),sum)
new_counts <- t(new_df)
colnames(new_counts) <- new_counts[1,]
new_counts <- new_counts[-1,]
df.i <- data.frame(new_counts)
#make dataframe numeric
df.i[] <- lapply(df.i, as.numeric)
```

3.2 Perform CCA, specifying that species is explained by environmental variables
```{r}
ccamodel1.i <- cca(df.i~., meta_med.i, na.action = na.exclude)
```

3.3 We now have to automatically select variables of "env" than best explain "spe". We can do this by using a stepwise model from the "ordistep" function. We'll just do this with 
```{r}
finalmodel1.i <- ordistep(ccamodel1.i, scope=formula(ccamodel1.i))
```

3.4 Next we calculate Variance Inflation Factors for each of the variables (constraints). If there is an env variable with VIF > 10 then this variable presents collinearity with other variables. We then have to delete from the dataset and redo our analysis.
```{r}
vif.cca(finalmodel1.i) #VIF scores > 10 Radius, Mass, Conductivity, Na_mg
keeps <- c("Total_Depth", "Temp", "pH", "DOC", "C", "TIN","C.N")
meta_trim_trim.i <- meta_trim.i[, (names(meta_trim.i) %in% keeps)]
meta_med.i=data.frame(apply(meta_trim_trim.i,2,f))
ccamodel2.i <- cca(df.i~., meta_med.i, na.action = na.exclude)
finalmodel2.i <- ordistep(ccamodel2.i, scope=formula(ccamodel2.i))
vif.cca(finalmodel2.i)
```

3.5 Call the ccamodel and interpret results
```{r}
ccamodel2.i

#test significance of the model
anova.cca(finalmodel2.i) # p <0.05 SIGNIFICANT!

#test significance of the terms
anova.cca(finalmodel2.i, by="terms") #sig terms: total depth, radius, mass, temp, conductivity, pH, DOC, C, TIN, C.N, NA_mg

#test significance of the CCA axes - at least the first two or three should present a significant p value
anova.cca(finalmodel2.i, by="axis") #the first two are significant

#plot a graph of results
plot(finalmodel2.i, xlim=c(-1.5,2), ylim=c(-1,1), display=c("sp", "cn"), main="Intermediate Taxa CCA Plot")
```

4 RARE TAXA

4.1 Prep data
```{r}
#pull out count table and metadata
counts.ra <- data.frame(t(otu_table(ps.glaciers.merged.RR)))
meta.ra <- data.frame(sample_data(ps.glaciers.merged.RR))

#keep only variables we want to include in our model
meta_trim.ra <- meta.ra[,17:92]
#calcualte area
meta_trim.ra$area <- pi*(meta_trim.ra$NS/2)*(meta_trim.ra$EW/2)
#remove diamter info
drops <- c("NS","EW")
meta_trim.ra <- meta_trim.ra[ , !(names(meta_trim.ra) %in% drops)]
#remove more unneccessary columns
meta_trim.ra <- meta_trim.ra[,-c(64:74)]
#make dataframe numeric
meta_trim.ra[] <- lapply(meta_trim.ra, as.numeric)

# #earlier correlation analysis suggested that pH, TDN, HCO3, Mass, NO3, NH4, elevation, ice lid thickeness, total depth, DOP, TDP, DRP, distance to sea, temp, TIN, K, F, C:N were most significantly related to our communities so I'm only going to include these variables - leave out DOP, NH4, C.N, TDN because not enough values
# #keeps.ab <- c("Distance_To_Sea", "Elevation", "Total Depth", "Ice_Lid", "Temp", "pH", "K_mueq", "HC03_mueq", "F", "area")
# keeps.ra <- c("Elevation", "Total_Depth", "Ice_Lid", "area", "Distance_To_Sea", "HC03_mueq")
# meta_trim_trim.ra <- meta_trim.ra[, (names(meta_trim.ra) %in% keeps.ra)]

# # #Initial CCA analysis suggested these were significant: #sig terms: #sig terms: Elevation, Total Depth, Rock water, ice lid, temp, ph, Cl_meq, K_mg - I'm going to re-run this analysis with these terms only
keeps <- c("Elevation", "Total_Depth", "Rock_Water", "Ice_Lid", "Temp", "pH", "Cl_meq", "K_mg")
meta_trim_trim.ra <- meta_trim.ra[, (names(meta_trim.ra) %in% keeps)]

#Replace NAs with median values
f=function(x){
   x<-as.numeric(as.character(x)) #first convert each column into numeric if it is from factor
   x[is.na(x)] =median(x, na.rm=TRUE) #convert the item with NA to median value from the column
   x #display the column
}
meta_med.ra=data.frame(apply(meta_trim_trim.ra,2,f))

#rename counts columns with phylum
tax_tab.ra <- data.frame(tax_table(ps.glaciers.merged.RR))
#replace NAs with Unknown
tax_tab.ra[is.na(tax_tab.ra)] <- "Unknown"
colnames(counts.ra) <- tax_tab.ra$Class

#aggregate count data
x <- t(counts.ra)
new_df=aggregate(x, by=list(rownames(x)),sum)
new_counts <- t(new_df)
colnames(new_counts) <- new_counts[1,]
new_counts <- new_counts[-1,]
df.ra <- data.frame(new_counts)
#make dataframe numeric
df.ra[] <- lapply(df.ra, as.numeric)
```

4.2 Perform CCA, specifying that species is explained by environmental variables
```{r}
ccamodel1.ra <- cca(df.ra~., meta_med.ra, na.action = na.exclude)
```

4.3 We now have to automatically select variables of "env" than best explain "spe". We can do this by using a stepwise model from the "ordistep" function. We'll just do this with 
```{r}
finalmodel1.ra <- ordistep(ccamodel1.ra, scope=formula(ccamodel1.ra))
```

4.4 Next we calculate Variance Inflation Factors for each of the variables (constraints). If there is an env variable with VIF > 10 then this variable presents collinearity with other variables. We then have to delete from the dataset and redo our analysis.
```{r}
vif.cca(finalmodel1.ra) #VIF scores > 10 Cl_meq and K_mg
keeps <- c("Elevation", "Total_Depth", "Rock_Water", "Ice_Lid", "Temp", "pH")
meta_trim_trim.ra <- meta_trim.ra[, (names(meta_trim.ra) %in% keeps)]
meta_med.ra=data.frame(apply(meta_trim_trim.ra,2,f))
ccamodel2.ra <- cca(df.ra~., meta_med.ra, na.action = na.exclude)
finalmodel2.ra <- ordistep(ccamodel2.ra, scope=formula(ccamodel2.ra))
vif.cca(finalmodel2.ra)
```

4.5 Call the ccamodel and interpret results
```{r}
ccamodel2.ra

#test significance of the model
anova.cca(finalmodel2.ra) # p < 0.05 SIGNIFICANT!

#test significance of the terms
anova.cca(finalmodel2.ra, by="terms") #sig terms: Elevation, Total Depth, Rock water, ice lid, temp, ph, Cl_meq, K_mg

#test significance of the CCA axes - at least the first two or three should present a significant p value
anova.cca(finalmodel2.ra, by="axis") #the first two are significant

#plot a graph of results
plot(finalmodel2.ra, xlim=c(-1.5,2), ylim=c(-1,1.5), display=c("sp", "cn"), main="Rare Taxa CCA Plot")
```
---
---
title: "28-02-21-metadata-analysis"
author: "Amy Solman"
date: "28/02/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This script will prepare our QIIME2 output for use in downstream analysis.

#Step One: Clear work space and load packages
```{r}
rm(list=ls())
graphics.off()

library(tidyverse)
library(phyloseq)
library(readr)
library(seqinr)
library(decontam)
library(vegan)
library(magrittr)
library(data.table)
library(ape) #appe::Ntip
```

#Step Two: Load the data from our QIIME2 step +metadata
```{r}
count_table <- read_tsv(file="../data/16S/qiime-output/exported-table/feature-table.tsv", skip=1)

#Specify the first column in our count table is the row names (ASV IDs)
count_table <- column_to_rownames(count_table, var = colnames(count_table)[1])

taxonomy <- read_tsv(file="../data/16S/qiime-output/exported-taxonomy/taxonomy.tsv")

fasta <- read.fasta(file="../data/16S/qiime-output/exported-rep-seqs/dna-sequences.fasta")

tree <- read_tree("../data/16S/qiime-output/exported-rooted-tree/tree.nwk")

metadata <- read.csv(file="../data/metadata.csv", sep=",")

#remove unneccesary data from the metadata file
metadata = metadata[! names(metadata) %in% c("SampleID_18S", "Read1_18S", "Read2_18S", "Barcode_18S", "Barcode_reverse_18S")]
#rename columns
names(metadata)[names(metadata) == 'SampleID_16S'] <- 'SampleID'
names(metadata)[names(metadata) == 'Read1_16S'] <- 'Read1'
names(metadata)[names(metadata) == 'Read2_16S'] <- 'Read2'
names(metadata)[names(metadata) == 'Barcode_53_16S'] <- 'Barcode_53'
names(metadata)[names(metadata) == 'Barcode_reverse_16S'] <- 'Barcode_reverse'
```

#Step Three: Identify contaminents in the count data
```{r}
# A logical vector showing which entries are 'TRUE' for controls and 'FALSE' for genuine samples
decontam <- startsWith(metadata$Name, "Neg")

# convert count table to dataframe
count_table_df <- as.data.frame(count_table)

# Run isContaminant, while transforming the matrix with t()
contam_df <- isContaminant(t(count_table_df), neg=decontam)

# What do our results look like?
table(contam_df$contaminant) 

# Make a vector holding contaminant IDs
contam_asvs <- row.names(contam_df[contam_df$contaminant == TRUE, ])

# Check the taxonomy of these contaminants
contam_tab <- taxonomy[taxonomy$`Feature ID` %in% contam_asvs, ]

#export contaminant table
contam_tab <- contam_tab %>%
  mutate(taxonomy=str_replace_all(string=Taxon, pattern="D_\\d*\\__", replacement="")) %>%
  mutate(taxonomy=str_replace_all(string=taxonomy, pattern=";$", replacement="")) %>%
separate(taxonomy, into=c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species"), sep=";") %>%
  select(-Taxon, -Confidence) %>%
  column_to_rownames(var='Feature ID')

write.csv(contam_tab, "../results/16S/contaminants/contaminant-asvs.csv")
```

#Step Four: Remove contaminents from count table,taxonomy table, metadata and tree
```{r}
###COUNT TABLE
x <- rownames(count_table) %in% contam_asvs #which rows are contaminants?
count_table_clean <- count_table[!x,] #remove those rows

# and remove blank samples from count table
#what is the index of "TRUE" values in decontam?
true_index <- NULL
for (i in 1:length(decontam)){
  if (decontam[[i]] == "TRUE"){
    true_index <- c(true_index, i)
  }
}
count_table_clean <- count_table_clean[,-c(true_index)]  #remove those samples

###TAXONOMY FILE
taxonomy_clean <- taxonomy[ ! taxonomy$`Feature ID` %in% contam_asvs, ]

###FASTA FILE
#Remove contaminants from dna sequences file
fasta_clean <- fasta
fasta_clean[contam_asvs] <- NULL

###METADATA TABLE
y <- startsWith(metadata$Name, "Neg")
true_index <- NULL
for (i in 1:length(y)){
  if (y[[i]] == "TRUE"){
    true_index <- c(true_index, i)
  }
}
metadata_clean <- metadata[-c(true_index),]  #remove those samples

###PHYLOGENETIC TREE
# This is a phyloseq object so we can use a phyloseq command called prune_taxa
tree_clean <- prune_taxa(count_table_clean$`#OTU ID`, tree)
```

#Step Five: Modify taxonomy table 
```{r}

#Now to modify the taxonomic table for my data
taxa_table_clean <- taxonomy_clean %>%
  mutate(taxonomy=str_replace_all(string=Taxon, pattern="D_\\d*\\__", replacement="")) %>%
  mutate(taxonomy=str_replace_all(string=taxonomy, pattern=";$", replacement="")) %>%
separate(taxonomy, into=c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species"), sep=";") %>%
  select(-Taxon, -Confidence) %>%
  column_to_rownames(var='Feature ID')

taxa_table <- taxonomy %>%
  mutate(taxonomy=str_replace_all(string=Taxon, pattern="D_\\d*\\__", replacement="")) %>%
  mutate(taxonomy=str_replace_all(string=taxonomy, pattern=";$", replacement="")) %>%
separate(taxonomy, into=c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species"), sep=";") %>%
  select(-Taxon, -Confidence) %>%
  column_to_rownames(var='Feature ID')

#rownames(taxa_table) == rownames(count_table_clean)
# 
# #I'm also going to add these phylogenetic classifications to my main count_table_clean for use in later analysis
# count_table_clean.tax <- merge(taxa_table, count_table_clean, by=0, all=TRUE) #merge our dataframes
# rownames(count_table_clean.tax)=count_table_clean.tax$Row.names #give ASV ID as row names
# count_table_clean.tax <- count_table_clean.tax[-c(1)] #remove additional row names column
```

#Step Six: Convert count_table, taxonomy table and metadata table to phyloseq objects
```{r}
ASV_clean = otu_table(as.matrix(count_table_clean), taxa_are_rows = TRUE)
TAX_clean = tax_table(as.matrix(taxa_table_clean))

ASV = otu_table(as.matrix(count_table), taxa_are_rows = TRUE)
TAX = tax_table(as.matrix(taxa_table))

#make into phyloseq object
ps <- phyloseq(ASV, TAX)
ps #84 samples
ps_clean <- phyloseq(ASV_clean, TAX_clean)
ps_clean #84 samples

#merge phyloseq object with metadata
META	=	sample_data(data.frame(metadata, row.names = sample_names(ps)))
ps.merge <- merge_phyloseq(ps, META)
ps.merge

META_clean = sample_data(data.frame(metadata_clean, row.names = sample_names(ps_clean)))
ps.merge_clean <- merge_phyloseq(ps_clean, META_clean)
ps.merge_clean

#finally add the phylogenetic tree
ps.merge2 <- merge_phyloseq(ps.merge, tree)
ps.merge2 #perfect!

ps.merge2_clean <- merge_phyloseq(ps.merge_clean, tree_clean)
ps.merge2_clean #perfect!
```

#Step Seven: remove abiguous annotations and singletons
```{r}
ps.ambig <- subset_taxa(ps.merge2, !is.na(Kingdom) & !Kingdom %in% c("Unassigned") & !Order %in% c("Chloroplast") & !Family %in% c("Mitochondria"))
ps.ambig

ps.ambig <- prune_taxa(taxa_sums(ps.ambig) > 1, ps.ambig) 

ps.ambig_clean <- subset_taxa(ps.merge2_clean, !is.na(Kingdom) & !Kingdom %in% c("Unassigned") & !Order %in% c("Chloroplast") & !Family %in% c("Mitochondria"))
ps.ambig_clean

ps.ambig_clean <- prune_taxa(taxa_sums(ps.ambig_clean) > 1, ps.ambig_clean) 
```

#Step Eight: Remove samples with less than 11000 sequences
```{r}
#how many reads do we have per sample
sample_sums(ps.ambig) 
sample_sums(ps.ambig_clean) 

# Remove samples with less than 10000 reads 
ps.prune <- prune_samples(sample_sums(ps.ambig) >= 11000, ps.ambig) 
ps.prune

ps.prune_clean <- prune_samples(sample_sums(ps.ambig_clean) >= 11000, ps.ambig_clean) 
ps.prune_clean
```

#Step Nine: Rarefy data
```{r}
#rarefy the data to minimum sample depth
ps.rar = rarefy_even_depth(ps.prune, rngseed=1, sample.size=min(sample_sums(ps.prune)), replace=F)
ps.rar
sample_sums(ps.rar)

ps.rar_clean = rarefy_even_depth(ps.prune_clean, rngseed=1, sample.size=min(sample_sums(ps.prune_clean)), replace=F)
ps.rar_clean
sample_sums(ps.rar_clean)

```

#Step Ten: Re-root tree because the root may have been removed through pruning. Use this function > (https://john-quensen.com/r/unifrac-and-tree-roots/) < picks longest branch
```{r}
# First define the function from link above to find furthest outgroup
pick_new_outgroup <- function(tree.unrooted){
  #tablif parts of the tree that we need
  treeDT <- 
    cbind(
      data.table(tree.unrooted$edge),
      data.table(length = tree.unrooted$edge.length)
    )[1:Ntip(tree.unrooted)] %>%
    cbind(data.table(id = tree.unrooted$tip.label))
  #Take out the longest terminal branch as outgroup
  new.outgroup <- treeDT[which.max(length)]$id
  return(new.outgroup)
}

# Run on my_phyloseq tree
my_tree <- phy_tree(tree)
new_outgroup <- pick_new_outgroup(my_tree)

my_tree_clean <- phy_tree(tree_clean)
new_outgroup_clean <- pick_new_outgroup(my_tree_clean)

# Re-root tree
new_tree <- ape::root(my_tree, outgroup=new_outgroup, resolve.root=TRUE)
new_tree_clean <- ape::root(my_tree_clean, outgroup=new_outgroup_clean, resolve.root=TRUE)

# Convert to dichotomy tree
new_tree2 <- ape::multi2di(new_tree)
phy_tree(ps.rar) <- new_tree2

new_tree2_clean <- ape::multi2di(new_tree_clean)
phy_tree(ps.rar_clean) <- new_tree2_clean
```

#Remove negative control sample
```{r}
ps.rar = subset_samples(ps.rar, Name != "NegCtrlBlank16")
ps.ambig = subset_samples(ps.ambig, Name != "NegCtrlBlank16")
```

#Step Thirteen: Save r data object and phyloseq object
```{r}
#r data object
# save(metadata, count_table_clean, count_table_clean.tax, taxonomy, taxonomy_clean, fasta, fasta_clean, tree, tree_clean, file = "../output/16S-sequence-data.RData")

#Now I'm going to export my phyloseq object
saveRDS(ps.ambig, "../results/16S/phylo-objects/16S-phyloseq-object.rds")
saveRDS(ps.rar, "../../results/16S/phylo-objects/16S-phyloseq-object-rarefied.rds")

saveRDS(ps.ambig_clean, "../results/16S/phylo-objects/16S-phyloseq-object-decontam.rds")
saveRDS(ps.rar_clean, "../results/16S/phylo-objects/16S-phyloseq-object-rarefied-decontam.rds")
```

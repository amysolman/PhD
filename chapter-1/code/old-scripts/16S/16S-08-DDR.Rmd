---
title: "Distance-Decay Analysis"
author: "Amy Solman"
date: "08/10/2021"
output: html_document
---
This script will look at the correlation between geographic distance and community dissimilarity.

I will achieve this by:
1) Calculating community dissimilarities
2) Calculating community distances (using lat and long coords)
3) Mantel tests for correlation between the matrices
4) Carry out linear regression of distances and dissimilarities
5) Plot the linear regressions

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Clear workspace and load packages
```{r}
rm(list=ls())
graphics.off()

# library(ggpubr) #for making my boxplots
# library(FSA) #for dunn's test
# library(vegan) #for diversity indices
# library(ggplot2) #for making plots
# library(dplyr) #for manipulating data where you see %>% and computing summary stats
# install.packages("dendextend")
# library(dendextend) #for hierchical clustering
# install.packages("indicspecies")
# library(indicspecies) #for indicator species analysis
library(stringr) #for removing characters from string
library(fossil) #for creating distance matrix
# # install.packages("betapart")
# library(betapart) #for didtance decay analysis
 library(ade4) #mantel tests
```

Load Data
```{r}
#TOTAL DATASET
ps <- readRDS("../../results/16S/phylo-objects/16S-phyloseq-object-rarefied-decontam.rds")

#Total Abundant
ps.abun <- readRDS("../../results/16S/phylo-objects/16S-total-abundant.rds")
#Total Intermediate
ps.int <- readRDS("../../results/16S/phylo-objects/16S-total-intermediate.rds")
#Total Rare
ps.rare <- readRDS("../../results/16S/phylo-objects/16S-total-rare.rds")
```

Function to return the p-value (https://gettinggeneticsdone.blogspot.com/2011/01/rstats-function-for-extracting-f-test-p.html)
```{r}
lmp <- function (modelobject) {
    if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
    f <- summary(modelobject)$fstatistic
    p <- pf(f[1],f[2],f[3],lower.tail=F)
    attributes(p) <- NULL
    return(p)
}

```

Function for finding community distances
```{r}
#Function testing area
# phylo = ps
# my_dist <- get_my_distances(ps)

get_my_distances <- function(phylo){
  
#get metadata
meta <- data.frame(sample_data(phylo))

#put a negative sign in front of all the south latitude coords
for (i in 1:nrow(meta)){
  if (meta$Pole[i] == "Antarctic"){
    meta$Glacier_Latitude[i] <- c(paste0("-", meta$Glacier_Latitude[i]))
    meta$Cryoconite_Latitude[i] <- c(paste0("-", meta$Cryoconite_Latitude[i]))
  }
}

#Some of our cryoconite holes don't have specific coords so we'll use the glacier coordinates
#remove letters from glacier coord strings
meta$Glacier_Latitude <- as.numeric(str_sub(meta$Glacier_Latitude,1,nchar(meta$Glacier_Latitude)-1))
meta$Glacier_Longitude <- as.numeric(str_sub(meta$Glacier_Longitude,1,nchar(meta$Glacier_Longitude)-1))

glac_lat <- meta$Glacier_Latitude
glac_long <- meta$Glacier_Longitude

#get latitude of each sample
cryo_lat <- as.numeric(meta$Cryoconite_Latitude)
#get longitude of each sample
cryo_long <- as.numeric(meta$Cryoconite_Longitude)

#replace any missing cryoconite coords with those of it's glacier
for (j in 1:length(cryo_lat)){
  if (is.na(cryo_lat[j])){
    cryo_lat[j] <- glac_lat[j]
    cryo_long[j] <- glac_long[j]
  }
}

#put into matrix
long.lat <- as.matrix(cbind(cryo_long, cryo_lat))

geo.dist <- earth.dist(long.lat, dist=TRUE) #a matrix of distances in kilometers between a list of longitudes and latitudes

  #change geo.dist from km to m
  geo.dist_m <- geo.dist*1000
  #plus 1 m to each distance so we can log10 them
  geo.dist_m_1 <- geo.dist_m + 1
  
return(geo.dist_m_1)
}

```

Function to return table with mantel correlation test and linear regression test results for community dissimilarities and distances
```{r}
#phylo = ps

distance_dissimilarity_correlations <- function(phylo){
  
  #get my distances
  my_dist <- get_my_distances(phylo)
  
  #get community dissimilarities
  DistWU <- distance(phylo, method="wUniFrac")
  DistUU <- distance(phylo, method="UniFrac")
  DistBray <- distance(phylo, method="bray")
  DistCan <- distance(phylo, method="canberra")
  
  # #mantel tests 
  # #Weighted UniFrac Distances
  # m1 <- mantel.rtest(my_dist, DistWU, nrepet = 9999)
  # #Unweighted UniFrac Distances
  # m2 <- mantel.rtest(my_dist, DistUU, nrepet = 9999)
  # #Bray-Curtis Distances
  # m3 <- mantel.rtest(my_dist, DistBray, nrepet = 9999)
  # #Canberra Distances
  # m4 <- mantel.rtest(my_dist, DistCan, nrepet = 9999)
  
  DDR.wuni <- lm(DistWU ~ log10(my_dist))
  summary(DDR.wuni) #p < 0.05 

  DDR.uni <- lm(DistUU ~ log10(my_dist))
  summary(DDR.uni) #p < 0.05

  DDR.bray <- lm(DistBray ~ log10(my_dist))
  summary(DDR.bray) #p < 0.05

  DDR.can <- lm(DistCan ~ log10(my_dist))
  summary(DDR.can) #p < 0.05
  
  # #create dataframe for results
  # results_dataframe <- data.frame(Distance=rep(c("wUniFrac", "UniFrac", "bray", "canberra"), 2), Test=c(rep("Mantel", 4), rep("lm", 4)), Pvalue = c(m1$pvalue, m2$pvalue, m3$pvalue, m4$pvalue, lmp(DDR.wuni), lmp(DDR.uni), lmp(DDR.bray), lmp(DDR.can)), Rvalue=c(NA, NA, NA, NA, as.numeric(summary(DDR.wuni)[9]), as.numeric(summary(DDR.uni)[9]), as.numeric(summary(DDR.bray)[9]), as.numeric(summary(DDR.can)[9])))
  
    #create dataframe for results
  results_dataframe <- data.frame(Distance=c("wUniFrac", "UniFrac", "bray", "canberra"), Pvalue = c(lmp(DDR.wuni), lmp(DDR.uni), lmp(DDR.bray), lmp(DDR.can)), Rvalue=c(as.numeric(summary(DDR.wuni)[9]), as.numeric(summary(DDR.uni)[9]), as.numeric(summary(DDR.bray)[9]), as.numeric(summary(DDR.can)[9])))
  
  return(results_dataframe)
}

```

Function to plot significant results
```{r}
#Function testing area
phylo = ps.rare
#my_plots <- plot_my_signif(ps)

plot_my_signif <- function(phylo, community){
  
  #find signficant correlations
  corrs_lm <- distance_dissimilarity_correlations(phylo) 
  
  #subset dataframe to lm results ONLY
  #corrs_lm <- corrs[corrs$Test == "lm",]
  
  #get distances
  distances <- get_my_distances(phylo)
  
  #list to store plots
  my_many_plots <- list()
  
  y <- 1
  
  for (z in 1:nrow(corrs_lm)){
    
    if (corrs_lm[z,]$Pvalue < 0.05){
      
      #get community dissimilarities for
      dissim <- distance(phylo, method=corrs_lm[z,]$Distance)
         
      plot(log10(distances), dissim, pch = 16, col = "blue",
       xlab="Log10 Distance (m)", ylab=corrs_lm[z,]$Distance) #Plot the results
      abline(lm(dissim ~ log10(distances))) #Add a regression line
      title(main=paste0(community, " DDR"))
      text(max(log10(distances))*0.2, max(dissim)*0.9, paste0("p= ", corrs_lm[z,]$Pvalue))
      text(max(log10(distances))*0.2, max(dissim)*0.8, paste0("AdjR= ", round(corrs_lm[z,]$Rvalue, digits = 3))) 
      
      #store the plot
      p <- recordPlot()
      plot.new() ## clean up device
      p # redraw
           
      my_many_plots[[y]] <- p
      y <- y + 1
      
      }

      
  }
  
  return(my_many_plots)
    
}
```

Function to print and save all my plots
```{r}
#Function testing area
# plots_list <- my_many_plots 
# community="total"

# plots_list = int_plots_shannon_group_1
# index = "Shannon"
# group = 1
# community = "intermediate"

save_my_plots <- function(plots_list, community){
  
  for (p in 1:length(plots_list)){
    
    plot_to_print <- plots_list[[p]]
    
    
    pdf(paste0("../../results/16S/graphs/DDR/", community, "-DDR-", p, ".pdf"))
    print(plot_to_print)
    dev.off()
  }
}


```

Get my DDRs
```{r}
total_plots <- plot_my_signif(ps, "Total")
save_my_plots(total_plots, "Total")
abun_plots <- plot_my_signif(ps.abun, "Abundant")
save_my_plots(abun_plots, "Abundant")
int_plots <- plot_my_signif(ps.int, "Intermediate")
save_my_plots(int_plots, "Intermediate")
rare_plots <- plot_my_signif(ps.rare, "Rare")
save_my_plots(rare_plots, "Rare")
```
